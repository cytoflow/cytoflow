package org.flowcyt.cfcs;
// CFCSCorrelatedData.java

/* ------------------------------------------------------------------------- *\
This software and documentation are provided 'as is' and Tree Star, Inc., its
contractors and partners specifically disclaim all other warranties, expressed
or implied, including but not limited to implied warranties of merchantability
and fitness for a particular purpose, or during any particular date range.

By using this software, you are agreeing to these limits of liability, and to
hold Tree Star harmless for any information, accurate or erroneous, that might
be generated by the program.  This software is intended for research use only.

Christopher Lane <cdl@best.classes> for Tree Star  1/16/2002      Copyright 2002
\* ------------------------------------------------------------------------- */


import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;

public final class CFCSCorrelatedData extends CFCSAbstractData implements CFCSErrorCodes
{

    // --------------------------------------------------------------------

    /* friendly */
    CFCSCorrelatedData(final CFCSDatatype datatype, final CFCSKeywords keywords)
    {
        super(CORRELATED, datatype, keywords);

        sizing = new CFCSDataSizing(keywords);

        datatype.setSizingObject(sizing);
    }

    // --------------------------------------------------------------------

    protected final byte[][][] cinchBytes(final byte[] bytes)
    {
        final int nBytes = sizing.getByteSize();
        final int innerRange = (parameters.getParameter(0)).getRange();
        final int outerRange = (parameters.getParameter(1)).getRange();

        final byte[][][] cinched = new byte[outerRange][innerRange][];

        for (int outer = 0, position = 0; outer < outerRange; outer++)
        {
            for (int inner = 0; inner < innerRange; inner++, position += nBytes)
            {
                byte[] cinch = cinched[outer][inner] = new byte[nBytes];

                System.arraycopy(bytes, position, cinch, 0, nBytes);
            }
        }

        return cinched;
    }

    // --------------------------------------------------------------------

    public final byte[] getBytes()
    {
        final int outer = (parameters.getParameter(1)).getRange();
        final int inner = (parameters.getParameter(0)).getRange();

        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();

        try
        {
            DataOutputStream stream = new DataOutputStream(buffer);

            for (int bin = 0; bin < outer; bin++)
            {
                try
                {
                    datatype.writeData(bin, inner, stream);
                }
                catch (IndexOutOfBoundsException exception)
                {
                    throw new CFCSError(CFCSNoSuchBin, bin);
                }
            }

            stream.close();
        }
        catch (IOException exception)
        {
            throw new CFCSError(CFCSIOError, exception);
        }

        byte[] bytes = buffer.toByteArray();

        return (sizing.isPackedData()) ? packBytes(bytes) : bytes;
    }

    // --------------------------------------------------------------------

    public final void setBytes(final byte[] bytes)
    {
        super.setBytes(bytes);

        final int range = (parameters.getParameter(1)).getRange();

        for (int bin = 0; bin < range; bin++)
        {
            try
            {
                datatype.readData(bin, cinched[bin]);
            }
            catch (IndexOutOfBoundsException exception)
            {
                throw new CFCSError(CFCSNoSuchBin, bin);
            }
        }
    }

    // --------------------------------------------------------------------

    public final void getArray(final int[][] table)
    {
        for (int outer = 0; outer < table.length; outer++)
        {
            try
            {
                datatype.getData(outer, table[outer]);
            }
            catch (IndexOutOfBoundsException exception)
            {
                throw new CFCSError(CFCSNoSuchBin, outer);
            }
            catch (CFCSDataScaleError exception)
            {
                throw new CFCSError(CFCSNotImplemented);
            }
            catch (CFCSDataSizeError exception)
            {
                throw new CFCSError(CFCSNotImplemented);
            }
        }
    }

    public final void setArray(final int[][] table)
    {
        int events = 0;

        for (int outer = 0; outer < table.length; outer++)
        {
            try
            {
                datatype.addData(table[outer]);
            }
            catch (CFCSDataScaleError exception)
            {
                throw new CFCSError(CFCSNotImplemented);
            }

            for (int inner = 0; inner < table[outer].length; inner++)
            {
                events += table[outer][inner];
            }
        }

        setCount(events);
    }

    // --------------------------------------------------------------------

    public final void getArray(final int nBytes, final byte[][][] table)
    {
        final int innerRange = (parameters.getParameter(0)).getRange();
        final int outerRange = (parameters.getParameter(1)).getRange();

        if (table.length < outerRange)
        {
            throw new CFCSError(CFCSInsufficientSpace, table.length);
        }

        for (int outer = 0; outer < outerRange; outer++)
        {
            byte[][] bins = table[outer];

            if (bins.length < innerRange)
            {
                throw new CFCSError(CFCSInsufficientSpace, bins.length);
            }

            for (int inner = 0; inner < innerRange; inner++)
            {
                byte[] bytes = bins[inner];

                if (bytes.length < nBytes)
                {
                    throw new CFCSError(CFCSInsufficientSpace, bytes.length);
                }

                byte[] cinch = cinched[outer][inner];

                int length = cinch.length;
                int limit = nBytes - length;

                for (int i = 0; i < limit; i++)
                    bytes[i] = 0;

                for (int i = 0; i < length; i++)
                    bytes[limit + i] = cinch[i];
            }
        }
    }

    public static final void setArray(final int nBytes, final byte[][][] table)
    {
        throw new CFCSError(CFCSNotImplemented);
    }

    // --------------------------------------------------------------------

}
